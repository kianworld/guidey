"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateWithoutTime = void 0;
var DateWithoutTime = /** @class */ (function () {
    function DateWithoutTime(dateOrYearOrDaysSinceEpoch, month, day) {
        if (!isNaN(dateOrYearOrDaysSinceEpoch)) {
            if (month)
                this.utcMidnightDateObj = new Date(Date.UTC(dateOrYearOrDaysSinceEpoch, month, day));
            else
                this.utcMidnightDateObj = new Date(dateOrYearOrDaysSinceEpoch * 86400000);
        }
        else {
            // if no date supplied, use Now.
            if (!dateOrYearOrDaysSinceEpoch)
                dateOrYearOrDaysSinceEpoch = new Date();
            // if initDate specifies a timezone offset, or is already UTC, just keep the date part, reflecting the date _in that timezone_
            if (typeof dateOrYearOrDaysSinceEpoch === "string" && dateOrYearOrDaysSinceEpoch.match(/(-\d\d|(\+|-)\d{2}:\d{2}|Z)$/gm)) {
                this.utcMidnightDateObj = new Date(dateOrYearOrDaysSinceEpoch.substring(0, 10) + "T00:00:00Z");
            }
            else {
                // if init date is not already a date object, feed it to the date constructor.
                if (!(dateOrYearOrDaysSinceEpoch instanceof Date))
                    dateOrYearOrDaysSinceEpoch = new Date(dateOrYearOrDaysSinceEpoch);
                // Vital Step! Strip time part. Create UTC midnight dateObj according to local timezone.
                this.utcMidnightDateObj = new Date(Date.UTC(dateOrYearOrDaysSinceEpoch.getFullYear(), dateOrYearOrDaysSinceEpoch.getMonth(), dateOrYearOrDaysSinceEpoch.getDate()));
            }
        }
    }
    DateWithoutTime.prototype.toISOString = function () {
        return this.utcMidnightDateObj.toISOString();
    };
    DateWithoutTime.prototype.getDate = function () {
        return this.utcMidnightDateObj.getUTCDate();
    };
    DateWithoutTime.prototype.getDay = function () {
        return this.utcMidnightDateObj.getUTCDay();
    };
    DateWithoutTime.prototype.getFullYear = function () {
        return this.utcMidnightDateObj.getUTCFullYear();
    };
    DateWithoutTime.prototype.getMonth = function () {
        return this.utcMidnightDateObj.getUTCMonth();
    };
    DateWithoutTime.prototype.getDaysSinceEpoch = function () {
        return this.utcMidnightDateObj.getTime() / 86400000;
    };
    DateWithoutTime.prototype.setDaysSinceEpoch = function (days) {
        this.utcMidnightDateObj = new Date(days * 86400000);
    };
    DateWithoutTime.prototype.setDate = function (date) {
        return this.utcMidnightDateObj.setUTCDate(date);
    };
    DateWithoutTime.prototype.setFullYear = function (year) {
        return this.utcMidnightDateObj.setUTCFullYear(year);
    };
    DateWithoutTime.prototype.setMonth = function (arg) {
        return this.utcMidnightDateObj.setUTCMonth(arg);
    };
    DateWithoutTime.prototype.addDays = function (days) {
        this.utcMidnightDateObj.setUTCDate(this.utcMidnightDateObj.getUTCDate() + days);
    };
    DateWithoutTime.prototype.toString = function () {
        return this.utcMidnightDateObj.toString();
    };
    DateWithoutTime.prototype.toLocaleDateString = function (locale, options) {
        options = options || {};
        Object.assign(options, { timeZone: "UTC" });
        return this.utcMidnightDateObj.toLocaleDateString(locale, options);
    };
    return DateWithoutTime;
}());
exports.DateWithoutTime = DateWithoutTime;
